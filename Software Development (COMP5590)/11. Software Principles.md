### Principle #1

**Product:** General, debugged, tested
**System:** Set of compatible tools

Principle #1: Building programming systems product is 9× harder than building a program

#### Complexity

**Essential complexity** 
- Large with no two parts alike 
- Complexity of logic is essential 
- Non-linear nature of software

**Accidental complexity**
- Imperfect programming tools
- Unless this is more than 9/10, order of magnitude improvement is impossible


### Principle #2

> There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity.

#### Work

**Unpartitionable work:**
Work that takes the same amount of time regardless of the number of people assigned:
`t = c.

**Perfectly partitionable:**
Time decreases with number of people:
`t = w/n.


**Requiring communication:** 
Workers need to coordinate and be trained:
`t = (w + k)/n

**Complex task:**
Each worker needs to coordinate with each other: 
`t = w/n + k ∗ n ∗ (n − 1)`

### Principle 3
Adding manpower to a late software project makes it later.


**Further sources of complexity**
- Every problem is unique with little repetition
- There might not be a stopping rule
- Solutions are not right or wrong

### The Cure (not the shit band)

- **Second system effect** - a second attempt.
- **Throw one away** - The first system may be too slow, too big, awkward to use, or all three.
- **Buy versus build** - The most radical solution for constructing software is to not construct it at all

### Coherence
Conceptual integrity dictates that the design must proceed from one mind, or a very small number of agreeing minds.

### Summary
1. Building a programming systems product is 9× harder than building a program. 
2. No single development will lead to order-of-magnitude improvements in productivity and reliability 
3. Adding manpower to a late software project makes it later